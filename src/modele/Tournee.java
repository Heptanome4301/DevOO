package modele;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Observable;

public class Tournee extends Observable{
	private Plan plan;
	private Collection<Chemin> chemins;
	private Collection<Livraison> livraisons;
	private Adresse entrepot;
	
	/**
	 * Une tournée contient la liste des livraisons.
	 * Elle sotck également l'itinéraire de la tournée (une liste de chemin)
	 * L'instance de tournée est crée par la classe plan, au chargement du
	 * fichier des livraison.
	 * La tournée est accessible par le contrôleur  
	 */
	public Tournee(Plan plan,Collection<Livraison> livraisons,Adresse entrepot){
		this.plan = plan;
		this.livraisons = livraisons;
		this.entrepot = entrepot;
		this.chemins = null;
	}
	
	/**
	 * Acces à l'itinéraire calculé
	 * 
	 * @return null si un appel à calculerTournee n'est pas fait auparavant
	 */
	public Collection<Chemin> getItineraire(){
		return chemins;
	} 
	
	/**
	 *  Génère les suites des instructions
	 *  que le livreur doit suivre pour effectuer sa tournée 
	 * @throws Exception si échec de création du fichier de sortie
	 * (soit le path n'est pas valide, ou que le calcul de la tournée n'est pas fait)
	 * @param FichierDeSortie 
	 * si un appel à calculerTournee n'est pas fait auparavant
	 * le fichier ne sera pas créé et une exception est levée
	 */
	public void feuilleDeRoute(String FichierDeSortie) throws Exception{}
	
	/**
	 * Applée par this.calculerTournee
	 *  Construction du graphe qui represente le cout des chemins 
	 *  entre chaque couple de livraison à effectuer
	 *  Pour se faire des appels à plan.calculerChemin sont effectués
	 *  Ce graphe sera passé comme parametre à la classe TSP
	 *  i,j : le cout du chemin entre l'adresse de id i et l'adresse  de l'id j
	 * @return un tableau de 2 dimensions representant les adresse
	 * de livraison 
	 */
	private int[][] construireGraphe(){
		return null;
	}
	
	/**
	 * Calcule la tournée qui passera par toutes les livraisons
	 * Cette methode fait appel entre autre à construireGraphe()
	 * puis TSP.chercherSolution
	 * Le resultat est obtenue en faisant TSP.getSolution() 
	 * ce resultat est "convertie" en chemin: faire appel à
	 * plan.calculerChemin()
	 * Enfin il est stocké dans l'attribut chemins, et accessible
	 * avec getIteneraire()
	 */
	public void calculerTournee(){ // TO DO
		//TSP.chercherSolution(
				construireGraphe() ;
		//);
		//TSP.getSolution() ;
		chemins = new ArrayList<Chemin>();
		chemins.add( plan.calculerChemin(null,null) ) ;
		
	}
	
	/**
	 *  Acces à la liste des livraisons à effecteur
	 *  (pour les afficher dans vue par exemple)
	 * @return Collection de Livraison
	 */
	public Collection<Livraison> getLivraison(){
		return livraisons;
	}
	
	public Collection<Livraison> getLivraisons() {
		return livraisons;
	}

	public void setLivraisons(Collection<Livraison> livraisons) {
		this.livraisons = livraisons;
	}

	public Plan getPlan() {
		return plan;
	}

	public Adresse getEntrepot() {
		return entrepot;
	}

	/**
	 * Modification de la tournée en lui ajoutant une
	 * nouvelle livraison.
	 * @param l la nouvelle livraison à ajouter
	 * @throws Exception si la livraison est déja existante
	 * 
	 * 
	 */
	//  ?? est ce que on doit recalculer automatiquement la tournée ??
	public void ajouterLivraison(Livraison l) throws Exception{
		
	}
	
	/**
	 * Modification de la tournée en lui retirant une Livraison
	 * @throws Exception si la livraison n'existe pas 
	 */
    //  ?? est ce que on doit recalculer automatiquement la tournée ??
	public void supprimerLivraison(Livraison L) throws Exception {}
	
	
	/**
	 * Modification de la tournée ...
	 * @throws Exception l1 == l2 ou pas contenu dans la liste des livraison 	
	 */
	public void echangerLivraison(Livraison l1,Livraison l2)throws Exception {}
	
	
	
	
}
